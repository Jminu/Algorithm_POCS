주어진 숫자 N을 위와 같은 연산을 이용해 1로 만드려고 할때,

최소 몇번의 연산이 필요한지를 출력하는것이 목표이다.



---

만약 1,2,3의 경우는 모두 1이다

**4의경우 4->3->1 또는 4->2->1 최소 2번의 연산이 필요하다**

(1을 빼면 3, 3의 경우의 연산 +1 )

(2를 나누면 2,2의 경우의 연산 +1)

**5의 경우 5->4->3->1 또는 5->4->2->1 최소 3번의 연산이 필요하다**

(1을 빼면 4,4의 경우의 연산 +1)

**6의 경우 6->3->1 최소 2번의 연산**

(3으로 나누고, 2의경우의 연산 +1)

(2으로 나누고,3의 경우의 연산 +1)



---



다음과 같은 규칙을 도출 할 수가 있다.

n의 경우 MIN(n-1의 경우의 연산+1, (2또는 3으로 나누어지면 나눠지고 남은 몫의 경우의 연산+1))



```c++
#include <iostream>
#include <algorithm>
using namespace std;

int dis[1000000];


int main() {
	int N;
	cin >> N;

	for (int i = 2; i <= N; i++)
	{
		dis[i] = dis[i - 1] + 1;

		if (i % 2 == 0) {
			dis[i] = min(dis[i], dis[i / 2] + 1);
		}
		if (i % 3 == 0) {
			dis[i] = min(dis[i], dis[i / 3] + 1);
		}
	}
	cout << dis[N];

	return 0;

	


}
```

